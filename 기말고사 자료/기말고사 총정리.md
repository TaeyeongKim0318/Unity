# Unity 기말고사 정리
## 출제 방식과 출제 영역
### 1. 문제 형식
- 오지선다행 객관식(1점 x 10문제)
- 단답 주관식(2점 x 5문제)
- 서술형 주관식(5점 x 2문제)
### 2. 시험 범위
- 오브젝트에 적용되는 컴포넌트 (Audio, Effects, Event, Navigation, 등)
  - 오브젝트에 적용되는 컴포넌트 이름, 기능 정도 외우기
- Physics와 Collider(충돌)
- 사용자 인터페이스(UI)
- 유니티 애니메이션
  - 서술형으로 출제
- 씬뷰의 여러가지 아이콘
  - 씬뷰의 로케이션 툴과 같은 이름들과 기능
- 빛(Light) 오브젝트
  - 빛 오브젝트의 4가지
- 증강현실(AR)과 가상현실(VR) 차이점
- VR 게임 구현하는 과정
  - 서술형으로 출제
<br>
<br>

## 기말고사 범위 정리
- 오브젝트에 적용되는 컴포넌트 (Audio, Effects, Event, Navigation, 등)
  - Physics 2D → Rigidbody 2D
  - Physics 2D → Circle Collider
  - Miscellaneous → Animator
  - Effects → Particle System
  - Audio → Audio Source
<br>

- 씬뷰의 여러가지 아이콘
  - Scene 제어
    | Tool | 기능 |
    | :-- | :-- |
    | Hand Tool | 씬 뷰에서의 카메라 이동을 위한 도구 |
    | Move Tool | 개체의 위치를 조정하는 데 사용 |
    | Rotate Tool | 개체의 회전을 조정하는 데 사용 |
    | Scale Tool | 개체의 크기를 조정하는 데 사용 |
    | Rect Tool | 2D 게임이나 인터페이스 요소를 만들 때 사용 |
    | Transform Tool | 개체의 위치, 회전 및 크기를 모두 조정하는 종합적인 도구 |
  - 기즈모(Gizmo)
    - 보이지 않는 요소를 시각적으로 나타내기 위한 아이콘을 기즈모라고 한다.
    - x, y, z축은 각각 r, g, b 컬러로 표시된다.

- Physics와 Collider
  - Physics
    - Physics는 유니티에 표준으로 속해 있는 물리 엔진
    - Physics를 쓰면 오브젝트를 간단하게 물리 동작에 맞춰 움직일 수 있음
    - Physics는 **Rigidbody** 컴포넌트와 **Collider** 컴포넌트로 구성
    - Rigidbody 컴포넌트는 '힘 계산(물체에 작용하는 중력이나 마찰 등의 힘 계산)'을 담당하고 Collider 컴포넌트는 '물체의 충돌 판정'을 담당
    - **Physics를 사용해 물리적인 동작을 하면 오브젝트에는 Rigidbody와 Collider라는 두 개**가 적용
  - Physics 활용하기
    - Physics를 쓰면 오브젝트를 간단하게 물리 법칙에 따라 움직일 수 있고, 충돌 판정도 자동으로 할 수 있음
    - **무대 위를 플레이어가 자유롭게 이동하는 액션 게임이나 복잡한 충돌 판정이 필요한 슈팅 게임**에 이상적임
  - Collider
    - 다른 오브젝트와 충돌 처리
    - Collider의 종류
      | 이름 | 모양 |
      | :-- | :-- |
      | Circle Collider 2D | 원형 콜라이더 |
      | Box Collider 2D | 사각형 콜라이더 |
      | Edge Collider 2D | 선형 콜라이더, 오브젝트 일부를 충돌 판정할 때 사용한다. |
      | Polygon Collider 2D | 다각형 콜라이더, 오브젝트에 정확히 맞도록 충돌 판정할 때 사용한다. |
    - 이동하는 오브젝트는 캡슐형 콜라이더를 사용하는 것이 나음
    - 콜라이더의 위치나 크기는 Inspector 창에서 변경할 수 있음
    - 콜라이더의 옵션에서 Freeze Rotation의 Z를 체크해서 플레이어의 회전 방지
  - Rigidbody
    - 배치한 오브젝트가 중력에 따라 낙하
    - 중력과 물리연산의 영향을 무시하려면 Rigidbody의 Body Type에서 드롭다운 목록을 열고 Kinematic을 선택
    - Rigidbody의 Gravity Scale을 조정해 중력값 조정 가능
  <br>

- 에니메이션 만들기
  - 움직임을 조금씩 변경한 스프라이트를 준비해 일전 간격으로 바꿔 주는 방식을 사용하는데, 이를 **스프라이트 애니메이션**이라고 함
  - 애니메이션 작성과 전환을 일관되게 할 수 있는 **메카님 구조**를 사용
  - **메카님**
    - 메카님은 애니메이션을 작성하고 실행할 때 유니티 에디터에서 일관되게 조작할 수 있는 기능
    - 게임을 설계할 때 스프라이트 애니메이션을 작성해 각 애니메이션의 교체 시기를 지정
    - 게임을 플레이할 때 메카님이 오브젝트 상태를 판단하고 자동으로 애니메이션을 바꿔 재생
    - 메카님을 사용하려면 스프라이트, 애니메이션 클립, 애니메이터 컨트롤러, 애니메이터 컴포넌트의 관계를 이해해야 함
  - **스프라이트와 애니메이션 클립**
    - 스프라이트 애니메이션을 사용할 수 있도록 스프라이트를 정리한 파일이 애니메이션 클립
    - '걷기 애니메이션'이나 '점프 애니메이션'처럼 애니메이션마다 애니메이션 클립을 준비
    - 에니메이션 클립에는 재생할 스프라이트 정보, 재생 속도, 재생 시간 등 정보를 설정
  - **애니메이션 클립과 애니메이터 컨트롤러**
    - 앞의 애니메이션 클립을 정리한 것이 애니메이터 컨트롤러
    - 애니메이터 컨트롤러로는 어느 시점에 어느 애니메이션 클립을 재생할지 지정
  - **애니메이션 컨트롤러와 애니메이터 컴포넌트**
    - 애니메이션하려는 오브젝트에 있는 애니메이터 컴포넌트에 애니메이터 컨트롤러를 설정하면 애니메이터 컨트롤러에서 정의한 애니메이션을 재생할 수 있음
    ```cs
    public class PlayerController : MonoBehaviour
    {
      Animator animator;

      void Start()
      {
        this.animator = GetComponent<Animator>();
      }

      void Update()
      {
        ...
      }
      ...
      // 플레이어 속도에 맞춰 애니메이션 속도를 바꾼다
      this.animator.speed = speedx / 2.0f;
    }
    ```
<br>


- **Physics로 충돌 판정하기**
  - Physics를 사용한 충돌 판정 종류에는 Collision 모드(충돌 모드)와 Trigger 모드(통과 모드)가 있음
  - 오브젝트가 충돌할 때 호출되는 메서드는 충돌 상태와 충돌 판정 모드에 따라 다음과 같이 정해져 있음(3D에서는 각각 대응되는 3D용 메서드가 호출)
    | 상태 | Collision 모드 | Trigger 모드 |
    | :-- | :-- | :-- |
    | 충돌한 순간 | OnCollisionEnter2D | OnTriggerEnter2D |
    | 충돌 중 | OnCollisonStay2D | OnTriggerStay2D |
    | 충돌이 끝난 순간 | OnCollisionExit2D | OnTriggerExit2D |
    ```cs
    ...
    // 곧 도착
    void OnTriggerEnter2D(Collider2D other)
    {
      Debug.Log("골");
    }
    ```
<br>

- Physics의 충돌 판정 조건
  - 판정할 모든 오브젝트에 Collider 컴포넌트가 적용되어 있어야 함
  - 충돌을 판정할 오브젝트 중 적어도 한쪽에는 Rigidbody 컴포넌트가 적용되어 있어야 함
<br>


- 파티클
  - 이펙트 관련 속성
  - Add Componenet 클릭 후 Effects → Particle System을 선택
<br>

- 라이트
  - 라이트의 종류
    | 라이트 | 역활 |
    | :-- | :-- |
    | Directional Light | 태양광처럼 직선으로 한곳을 향해 나란히 가면서 빛을 비추는 라이트다. 라이트에서 떨어져도 빛의 세기가 감쇠하지 않는다.|
    | Point Light | 전체 방향으로 동등하게 빛을 비추는 라이트다. 라이트에서 벗어나면 빛의 세기가 감쇠한다. |
    | Spotlight | 특정 방향에서 방사상(중앙에서 사방으로 뻗어나간 모양)으로 빛을 비추는 라이트다. 라이트에서 벗어나면 빛의 세기가 감쇠한다. |
    | Area Light | 직사각의 평면에서 전체 방위로 투사되는 라이트다. 라이트를 베이크 할 때만 사용할 수 있다. |
  ![라이트의 종류](Img/라이트의%20종류.png)
<br>

- VR 게임 설계하기
  1. 화면에 놓일 오브젝트를 나열
  2. 오브젝트를 움직일 수 있는 컨트롤러 스크립트 정하기
  3. 오브젝트를 자동으로 생성할 수 있도록 제너레이터 스크립트 정하기
     - 게임 플레이할 때 생성될 오브젝트 찾기
     - 오브젝트를 자동으로 생성하기 위해 재너레이터 스크립트 준비하기
  4. UI를 갱신할 수 있도록 감독 스크립트를 준비
  5. 스크립트를 만드는 흐름을 생각
     - 컨트롤러 스크립트 → 제너레이터 스크립트 → 감독 스크립트 순서
<br>

- VR과 AR 비교
  - VR은 우리가 가상세계 안으로 완전히 진입하기 때문에 몰입감이 높음
  - AR은 우리가 있는 현실로 가상세계를 소환하기 때문에 현실감이 높음
  - 증강 현실(AR)과 가상현실(VR)의 하드웨어 차이점은 유무